{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1504570"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "from MLABvo.Bolidozor import Bolidozor\n",
    "import json\n",
    "import datetime\n",
    "import numpy as np\n",
    "import scipy.signal\n",
    "from astropy.io import fits\n",
    "import matplotlib.pyplot as plt\n",
    "import matplotlib.dates as md\n",
    "from matplotlib import dates\n",
    "import sys\n",
    "sys.path.append(\"..\") \n",
    "import recviewer\n",
    "import dateutil.parser\n",
    "\n",
    "%matplotlib inline "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1504570"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 10, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(3)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[0]=0\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "selected.remove(0)\n",
    "selected.remove(1)\n",
    "selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[0]=0\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "selected.remove(0)\n",
    "selected.remove(1)\n",
    "selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=1\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "selected.remove(0)\n",
    "selected.remove(1)\n",
    "selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "selected.remove(0)\n",
    "selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1503331"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 10, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 45,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "selected.remove(0)\n",
    "selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1502542"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1487089"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 77,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    print (i, bolid['time_calib']['cor_file_beg'])\n",
    "    hdulist = fits.open(bolid['url_file_raw'])\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    \n",
    "    T_offset = 10*time_offset.get(selected[i], 0)\n",
    "    \n",
    "    if gps_calib:\n",
    "        min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    else:\n",
    "        min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "    array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "    \n",
    "    if not minimal_time: minimal_time = min_date\n",
    "    if not maximal_time: maximal_time = max_date\n",
    "    if min_date < minimal_time: minimal_time = min_date\n",
    "    if max_date > maximal_time: maximal_time = max_date\n",
    "    \n",
    "    ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "    ax.plot(met_data, array)\n",
    "    ax.grid(True)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print e\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 87,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1426132"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 88,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "\n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 93,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 95,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9:  calibration_data['quality'] = 0\n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if i in selected and bolid['time_calib']['quality'] > 50:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 100,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s\" %(multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s (%s)\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 108,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1393276"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 112,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9:  calibration_data['quality'] = 0\n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 114,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 115,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1402641"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 116,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 117,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 118,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9:  calibration_data['quality'] = 0\n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 120,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1402641"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1504571"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 124,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 126,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 127,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9:  calibration_data['quality'] = 0\n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 128,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9: \n",
    "        calibration_data['quality'] = 0\n",
    "        break\n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 130,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9: calibration_data['quality'] = 0\n",
    "        \n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 131,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 133,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 134,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 135,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s (%s)\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1440053"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 140,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9: calibration_data['quality'] = 0\n",
    "        \n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 142,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s (%s)\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [],
   "source": [
    "multibolid_id = 1504571"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [],
   "source": [
    "bz = Bolidozor()\n",
    "bolids = bz.getMultibolid(id=multibolid_id)\n",
    "print('Počet detekcí ve skupině je',len(bolids.result))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {},
   "outputs": [],
   "source": [
    "print(list(bolids.result[0].keys()))\n",
    "print(\"\")\n",
    "print(bolids.result[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 149,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i+1,'z',len(bolids.result))\n",
    "    fits.open(bolid['url_file_raw'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [],
   "source": [
    "def timeCalibration(raw_file, sigma = 15, debug = True):\n",
    "    calibration_data = {}\n",
    "    hdulist = fits.open(raw_file, cache=True)\n",
    "    met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "    clip_val = np.std(met_data)*sigma\n",
    "    plt.axhline(y=clip_val, color='red')\n",
    "    max_val = np.max(met_data)\n",
    "    for i, point in enumerate(met_data):\n",
    "        if point > clip_val:\n",
    "            plt.axvline(x=i, color='red')\n",
    "            ten_sec = 10/(hdulist[0].header['CDELT2']/2/1000.0)\n",
    "            if debug: plt.axvline(x=i+ten_sec, color='green')\n",
    "            break\n",
    "    #file_length = hdulist[0].header['NAXIS2']*hdulist[0].header['CDELT2']/1000.0\n",
    "    file_length = hdulist[0].header['NAXIS2']*1/96000\n",
    "    time_firstGPS = i/2*1/96000\n",
    "    DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    DATE = datetime.datetime.strptime(hdulist[0].header['DATE'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "    \n",
    "    gps = (DATE-datetime.timedelta(seconds=file_length-time_firstGPS)).timestamp()\n",
    "    round_gps = round(gps/10.0)*10\n",
    "    correction = datetime.timedelta(seconds=round_gps-gps)\n",
    "    \n",
    "    calibration_data['quality'] = 100\n",
    "    if clip_val > 0.9: calibration_data['quality'] = 0\n",
    "        \n",
    "        \n",
    "    \n",
    "    calibration_data['sys_correction'] = correction\n",
    "    \n",
    "    calibration_data['sys_file_beg'] = DATE-datetime.timedelta(seconds=file_length)\n",
    "    calibration_data['sys_file_end'] = DATE\n",
    "    calibration_data['sys_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    calibration_data['sys_error'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)\n",
    "    \n",
    "    calibration_data['cor_file_beg'] = DATE-datetime.timedelta(seconds=file_length)+correction\n",
    "    calibration_data['cor_file_end'] = DATE+correction\n",
    "    calibration_data['cor_1st_GPS'] = DATE-datetime.timedelta(seconds=file_length-time_firstGPS)+correction\n",
    "    calibration_data['cor_error'] = correction\n",
    "    \n",
    "    if debug:\n",
    "        #DATE_OBS = datetime.datetime.strptime(hdulist[0].header['DATE-OBS'], \"%Y-%m-%dT%H:%M:%S\" )\n",
    "        print(\"Zpracovavam soubor:\", raw_file)\n",
    "        print('delka zaznamu          :', file_length, \"s\")\n",
    "        print('cas prvni vzorku s GPS :', time_firstGPS, \"s\")\n",
    "        print('cas 1. GPS a konec     :', file_length - time_firstGPS, \"s\")\n",
    "        print('SysCas ukladani souboru:', calibration_data['sys_file_end'], \"s\")\n",
    "        print('SysCas zacatku souboru :', calibration_data['sys_file_beg'])\n",
    "        print('SysCas 1. GPS znacky   :', calibration_data['sys_1st_GPS'])\n",
    "        print('Korekce systémoveho čas:', correction)\n",
    "        print('CorCas ukladani souboru:', calibration_data['cor_file_end'], \"s\")\n",
    "        print('CorCas zacatku souboru :', calibration_data['cor_file_beg'])\n",
    "        print('CorCas 1. GPS znacky   :', calibration_data['cor_1st_GPS'])\n",
    "        print('Kvalita souboru        :', calibration_data['quality'])\n",
    "        plt.plot(met_data)\n",
    "        plt.show()\n",
    "    return calibration_data\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    print(i,\"==================================\")\n",
    "    print(\"snapshot:\", bolid['url_file_js9'])\n",
    "    bolids.result[i]['time_calib']=timeCalibration(bolid['url_file_raw'])\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 152,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "#time_offset[3]=0.5\n",
    "#time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s (%s)\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 156,
   "metadata": {},
   "outputs": [],
   "source": [
    "time_offset = {}\n",
    "selected = list(range(0, len(bolids.result)))     # vyber vsech dat\n",
    "\n",
    "#selected.remove(0)\n",
    "#selected.remove(1)\n",
    "#selected.remove(4)\n",
    "#selected = [0,1,2,3,6]\n",
    "\n",
    "#selected = [3,4,5,6]     #Pokud chcete vybrat konkrétní data, \n",
    "                               #odkomentujte tento řádek a vložte do něj čísla požadovaných dat\n",
    "\n",
    "# time_offset[0] = +0   ## Posun času na stanici.\n",
    "                        # Timto posunete data pro určitou stanici (podle indexu souboru)\n",
    "                        # o určitý počet časových značek (10s intervalů)\n",
    "                        # Kladné číslo posune graf 'nahoru\" \n",
    "time_offset[3]=0.5\n",
    "time_offset[4]=0.5\n",
    "#time_offset[1]=1\n",
    "for i, bolid in enumerate(bolids.result):\n",
    "    if bolid['time_calib']['quality'] < 50:\n",
    "        selected.remove(i)\n",
    "    if i in selected:\n",
    "        print(i, ',sysT of gps:', bolid['time_calib']['cor_1st_GPS'], ',offset:', bolid['time_calib']['cor_error'], bolid['filename'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 157,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "gps_calib = True\n",
    "minimal_time = None\n",
    "maximal_time = None\n",
    "\n",
    "for i, ax in enumerate(axis):\n",
    "    try:\n",
    "        bolid = bolids.result[selected[i]]\n",
    "        print (i, bolid['time_calib']['cor_file_beg'])\n",
    "        hdulist = fits.open(bolid['url_file_raw'])\n",
    "        met_data = np.abs(np.ravel(hdulist[0].data))\n",
    "\n",
    "        T_offset = 10*time_offset.get(selected[i], 0)\n",
    "\n",
    "        if gps_calib:\n",
    "            min_date = bolid['time_calib']['cor_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['cor_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        else:\n",
    "            min_date = bolid['time_calib']['sys_file_beg'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "            max_date = bolid['time_calib']['sys_file_end'].replace(tzinfo=datetime.timezone.utc).timestamp()+T_offset\n",
    "        array = np.arange(min_date, max_date, (max_date-min_date)/(len(met_data)))\n",
    "\n",
    "        if not minimal_time: minimal_time = min_date\n",
    "        if not maximal_time: maximal_time = max_date\n",
    "        if min_date < minimal_time: minimal_time = min_date\n",
    "        if max_date > maximal_time: maximal_time = max_date\n",
    "\n",
    "        ax.set_title(bolid['namesimple'] + \" (\" + str(selected[i])+\")\")\n",
    "        ax.plot(met_data, array)\n",
    "        ax.grid(True)\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "\n",
    "fig.subplots_adjust(hspace=0)\n",
    "print(minimal_time, maximal_time)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 158,
   "metadata": {},
   "outputs": [],
   "source": [
    "def waterfall(signal, sample_rate=None, bins = 4096 ):\n",
    "    waterfall = recviewer.waterfallize(signal, bins)\n",
    "    waterfall[np.isneginf(waterfall)] = np.nan\n",
    "    wmin, wmax = np.nanmin(waterfall), np.nanmax(waterfall)\n",
    "    return waterfall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 159,
   "metadata": {},
   "outputs": [],
   "source": [
    "%matplotlib inline \n",
    "#%matplotlib notebook\n",
    "count = len(selected)\n",
    "fig, axis = plt.subplots(1, count, sharex=True, sharey=True, figsize=(20, 10))\n",
    "\n",
    "print(time_offset)\n",
    "fig.suptitle(\"Multibolid %s (%s)\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "fig.subplots_adjust(hspace=0)\n",
    "plt.set_cmap('hot')\n",
    "for i, ax in enumerate(axis):\n",
    "    bolid = bolids.result[selected[i]]\n",
    "    hdu = fits.open(bolid['url_file_raw'])[0]\n",
    "    flat_data = np.ravel(hdu.data)\n",
    "    \n",
    "    T_offset = datetime.timedelta(seconds = 10*time_offset.get(selected[i], 0))\n",
    "    #print(i, selected[i], bolid['time_calib']['cor_file_beg'], bolid['time_calib']['cor_file_beg']+T_offset, T_offset)\n",
    "    d1 = bolid['time_calib']['cor_file_beg']+T_offset\n",
    "    fds1 = dates.date2num(d1) # converted\n",
    "    d2 = d1 + datetime.timedelta(seconds=hdu.header['NAXIS2']/48000.0/2)\n",
    "    fds2 = dates.date2num(d2)\n",
    "    \n",
    "    arr = waterfall(flat_data[0::2] + 1j * flat_data[1::2], 48000, bins = 4096*4)\n",
    "    ax.imshow(arr,  interpolation='none', aspect='auto',  extent=[-24000, 24000, fds2, fds1])\n",
    "    ax.grid(True)\n",
    "    \n",
    "    ax.set_xlim(13000,13500)\n",
    "    ax.yaxis_date()\n",
    "    date_format = md.DateFormatter('%H:%M:%S')\n",
    "    ax.yaxis.set_major_formatter(date_format)\n",
    "    fig.autofmt_xdate()\n",
    "    ax.set_ylim( datetime.datetime.utcfromtimestamp(minimal_time), datetime.datetime.utcfromtimestamp(maximal_time))\n",
    "    \n",
    "    offset = abs(bolid['time_calib']['cor_error']).microseconds/1000000 + abs(bolid['time_calib']['cor_error']).seconds\n",
    "    if bolid['time_calib']['cor_error'] < datetime.timedelta(seconds=0): offset = -offset\n",
    "    #ax.set_title(bolid['namesimple']+ \" err:\"+str(offset))\n",
    "    ax.set_title(bolid['namesimple'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 160,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook -e \"Multibolid_%s_%s\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 161,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook \"Multibolid_%s_%s\" %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 162,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook \"Multibolid_%s_%s\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 163,
   "metadata": {},
   "outputs": [],
   "source": [
    "%notebook \"Multibolid_%s_%s\"%('aa', 'bb')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 164,
   "metadata": {},
   "outputs": [],
   "source": [
    "file = 'aa'\n",
    "%notebook file"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {},
   "outputs": [],
   "source": [
    "$export = './export/multiboli_%s_%s' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 166,
   "metadata": {},
   "outputs": [],
   "source": [
    "from custom_magics import Macro\n",
    "$export = './export/multiboli_%s_%s' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 167,
   "metadata": {},
   "outputs": [],
   "source": [
    "from custom_magics import Macro\n",
    "Macro(\"export\", './export/multiboli_%s_%s'\n",
    "      %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id))\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {},
   "outputs": [],
   "source": [
    "$export = './export/multiboli_%s_%s' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 169,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multiboli_%s_%s' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 170,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multibolid_%s_%s.ipnb' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 171,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multibolid_%s_%s.ipnb' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 172,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multibolid_%s_%s.ipynb' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 173,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multibolid_%s_%s.ipynb' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook -e $export"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 174,
   "metadata": {},
   "outputs": [],
   "source": [
    "export = './export/multibolid_%s_%s.ipynb' %(datetime.datetime.utcfromtimestamp(minimal_time).date(), multibolid_id)\n",
    "%notebook -e $export"
   ]
  }
 ],
 "metadata": {},
 "nbformat": 4,
 "nbformat_minor": 2
}
